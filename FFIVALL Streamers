import discord
import asyncio
import requests
import subprocess
import os
import sys
import ctypes
import json
from discord.ext import tasks, commands
from dotenv import load_dotenv
import re
from discord import app_commands
from datetime import datetime
import ctypes

# Set custom console window title
ctypes.windll.kernel32.SetConsoleTitleW("FFIVALLRace Streamers")
# === Admin Check (Windows Only) ===
def is_admin():
    try:
        return ctypes.windll.shell32.IsUserAnAdmin()
    except:
        return False

if not is_admin():
    print("üîí Not running as admin. Attempting to restart with admin rights...")
    args = ' '.join(f'"{arg}"' for arg in sys.argv)
    ret = ctypes.windll.shell32.ShellExecuteW(None, "runas", sys.executable, args, None, 1)
    if ret <= 32:
        print(f"‚ùå Failed to elevate privileges. ShellExecuteW returned {ret}")
        sys.exit(1)
    else:
        sys.exit(0)

# === Load Environment Variables ===
load_dotenv(r"path_to_file")

# === Bot Settings ===
TOKEN = os.getenv("DISCORD_TOKEN")
GUILD_ID = int(os.getenv("GUILD_ID"))
CHANNEL_ID = int(os.getenv("CHANNEL_ID"))
TWITCH_CLIENT_ID = os.getenv("TWITCH_CLIENT_ID")
TWITCH_CLIENT_SECRET = os.getenv("TWITCH_CLIENT_SECRET")
REGISTER_FILE = os.getenv("REGISTER_FILE", "registered_twitch.json")
ALLOWED_GAMES_FILE = os.getenv("ALLOWED_GAMES_FILE", "allowed_games.json")
KEYWORD_FILTERS_FILE = os.getenv("KEYWORD_FILTERS_FILE", "allowed_keywords.json")
ACTIVE_NOTIFICATIONS_FILE = os.getenv("ACTIVE_NOTIFICATIONS_FILE", "active_notifications.json")

# === Base Filters ===
BASE_ALLOWED_GAMES = [game.lower() for game in ["Final Fantasy", "Final Fantasy IV", "Final Fantasy VI", "Final Fantasy Mystic Quest"]]
BASE_KEYWORD_FILTERS = [kw.lower() for kw in ["worlds collide", "free enterprise", "FF4FE", "Randomizer", "FFMQR", "FF6WC"]]

# === Load dynamic filters from JSON or create files if missing ===
def load_json_list(filepath, default_list):
    if not os.path.exists(filepath):
        with open(filepath, "w") as f:
            json.dump(default_list, f, indent=4)
        return default_list.copy()
    try:
        with open(filepath, "r") as f:
            data = json.load(f)
        return [item.lower() for item in data]
    except (json.JSONDecodeError, IOError):
        return default_list.copy()

def save_json_list(filepath, data):
    with open(filepath, "w") as f:
        json.dump(sorted(data), f, indent=4)

ALLOWED_GAMES = load_json_list(ALLOWED_GAMES_FILE, BASE_ALLOWED_GAMES)
KEYWORD_FILTERS = load_json_list(KEYWORD_FILTERS_FILE, BASE_KEYWORD_FILTERS)

print(f"Loaded allowed games: {ALLOWED_GAMES}")
print(f"Loaded keyword filters: {KEYWORD_FILTERS}")

# === Registered Twitch Users List ===
if not os.path.exists(REGISTER_FILE):
    try:
        with open(REGISTER_FILE, "x") as f:
            json.dump([], f)
        print(f"‚úÖ Created {REGISTER_FILE} file.")
    except Exception as e:
        print(f"‚ùå Failed to create {REGISTER_FILE}: {e}")

def load_registered_users():
    try:
        with open(REGISTER_FILE, "r") as f:
            return json.load(f)
    except (FileNotFoundError, json.JSONDecodeError):
        print(f"‚ö†Ô∏è {REGISTER_FILE} not found or invalid, creating new one.")
        save_registered_users([])
        return []

def save_registered_users(data):
    with open(REGISTER_FILE, "w") as f:
        json.dump(data, f, indent=4)

# === Load/save active_notifications persistence ===
def load_active_notifications():
    if not os.path.exists(ACTIVE_NOTIFICATIONS_FILE):
        return {}
    try:
        with open(ACTIVE_NOTIFICATIONS_FILE, "r") as f:
            return json.load(f)
    except (json.JSONDecodeError, IOError):
        return {}

def save_active_notifications(data):
    with open(ACTIVE_NOTIFICATIONS_FILE, "w") as f:
        json.dump(data, f, indent=4)

# === Discord Client ===
intents = discord.Intents.default()
intents.message_content = True
intents.guilds = True

client = commands.Bot(command_prefix="!", intents=intents)

# Load active notifications on startup
active_notifications = load_active_notifications()

# === Twitch API Utilities ===
twitch_access_token = None

def get_twitch_token():
    url = "https://id.twitch.tv/oauth2/token"
    params = {
        "client_id": TWITCH_CLIENT_ID,
        "client_secret": TWITCH_CLIENT_SECRET,
        "grant_type": "client_credentials"
    }
    print("üîë Requesting new Twitch OAuth token...")
    response = requests.post(url, params=params)
    if response.status_code == 200:
        print("‚úÖ Obtained new Twitch access token.")
        return response.json()["access_token"]
    else:
        print(f"‚ùå Failed to get Twitch token: {response.text}")
        return None

def check_twitch_status(username):
    global twitch_access_token
    if not twitch_access_token:
        twitch_access_token = get_twitch_token()
        if not twitch_access_token:
            return False, None, None

    headers = {
        "Client-ID": TWITCH_CLIENT_ID,
        "Authorization": f"Bearer {twitch_access_token}"
    }
    print(f"üåê Checking Twitch API for {username}...")
    url = f"https://api.twitch.tv/helix/streams?user_login={username.lower()}"
    response = requests.get(url, headers=headers)

    if response.status_code == 401:
        print("üîÑ Twitch token expired. Refreshing...")
        twitch_access_token = get_twitch_token()
        if not twitch_access_token:
            return False, None, None
        headers["Authorization"] = f"Bearer {twitch_access_token}"
        response = requests.get(url, headers=headers)

    if response.status_code == 200:
        data = response.json()
        if data.get("data"):
            stream = data["data"][0]
            title_lower = stream.get("title", "").lower()
            game_name = stream.get("game_name", "").lower()
            print(f"üé• Stream data for {username}: game='{game_name}', title='{stream.get('title')}'")

            if game_name in ALLOWED_GAMES:
                print(f"‚úÖ Game '{game_name}' is allowed.")
            else:
                print(f"‚ùå Game '{game_name}' is NOT in ALLOWED_GAMES.")

            keyword_matches = [kw for kw in KEYWORD_FILTERS if kw in title_lower]
            if keyword_matches:
                print(f"‚úÖ Keywords matched in title: {keyword_matches}")
            else:
                print(f"‚ùå No keyword matches in title.")

            if game_name in ALLOWED_GAMES and keyword_matches:
                return True, game_name, stream.get("title")
            else:
                print(f"‚ö†Ô∏è Stream filtered out: game='{game_name}', title='{stream.get('title')}'")
        else:
            print(f"‚ÑπÔ∏è No live data for {username}.")
    else:
        print(f"‚ùå Twitch API Error ({username}): {response.status_code} {response.text}")
    return False, None, None

# === Background Task ===
@tasks.loop(seconds=30)
async def check_twitch_status_task():
    print("üîÑ Running Twitch status check...")
    guild = client.get_guild(GUILD_ID)
    channel = guild.get_channel(CHANNEL_ID)
    if not guild or not channel:
        print("‚ùå Could not find guild or channel.")
        return

    users = load_registered_users()
    print(f"‚úÖ Loaded {len(users)} registered users from {REGISTER_FILE}.")

    for username in users:
        is_live, game, title = check_twitch_status(username)
        print(f"‚ÑπÔ∏è Checked live status for {username}: is_live={is_live}")

        if is_live and username not in active_notifications:
            message = await channel.send(
                f"üî¥ **{username} is now live!**\n"
                f"üéÆ Playing: {game}\n"
                f"üì∫ Title: {title}\n"
                f"https://twitch.tv/{username}"
            )
            active_notifications[username] = {
                "message_id": message.id,
                "last_title": title
            }
            save_active_notifications(active_notifications)

        elif is_live and username in active_notifications:
            last_title = active_notifications[username]["last_title"]
            if title != last_title:
                print(f"‚úèÔ∏è Title changed for {username}: '{last_title}' -> '{title}'")
                try:
                    message_id = active_notifications[username]["message_id"]
                    message = await channel.fetch_message(message_id)
                    timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
                    await message.edit(content=(
                        f"üî¥ **{username} is now live!**\n"
                        f"üéÆ Playing: {game}\n"
                        f"üì∫ Title: {title}\n"
                        f"https://twitch.tv/{username}\n"
                        f"*Last updated: {timestamp}*"
                    ))
                    active_notifications[username]["last_title"] = title
                    save_active_notifications(active_notifications)
                    print(f"‚úÖ Updated notification message for {username}.")
                except discord.NotFound:
                    print(f"‚ö†Ô∏è Original message for {username} not found, sending new one.")
                    message = await channel.send(
                        f"üî¥ **{username} is now live!**\n"
                        f"üéÆ Playing: {game}\n"
                        f"üì∫ Title: {title}\n"
                        f"https://twitch.tv/{username}"
                    )
                    active_notifications[username] = {
                        "message_id": message.id,
                        "last_title": title
                    }
                    save_active_notifications(active_notifications)

        elif not is_live and username in active_notifications:
            try:
                message_id = active_notifications[username]["message_id"]
                message = await channel.fetch_message(message_id)
                await message.delete()
                print(f"‚ùå Stream ended for {username} ‚Äî notification deleted.")
            except discord.NotFound:
                print(f"‚ö†Ô∏è Notification for {username} already deleted.")
            except Exception as e:
                print(f"‚ùå Error deleting notification for {username}: {e}")
            del active_notifications[username]
            save_active_notifications(active_notifications)

# === Slash Commands ===
@client.tree.command(name="register", description="Add a Twitch streamer to the watch list (use Twitch username)")
async def register_twitch(interaction: discord.Interaction, twitch_username: str):
    username = twitch_username.strip()
    if not re.match(r"^[a-zA-Z0-9_]+$", username):
        await interaction.response.send_message(
            "‚ùå Invalid Twitch username. Usernames can only contain letters, numbers, and underscores.",
            ephemeral=True
        )
        return
    users = load_registered_users()
    if any(u.lower() == username.lower() for u in users):
        await interaction.response.send_message(
            f"‚ö†Ô∏è Twitch username **{username}** is already registered.",
            ephemeral=True
        )
        return
    users.append(username)
    save_registered_users(users)
    await interaction.response.send_message(
        f"‚úÖ Registered Twitch username **{username}** for alerts.",
        ephemeral=True
    )

@client.tree.command(name="unregister", description="Remove a Twitch streamer from the watch list")
async def unregister_twitch(interaction: discord.Interaction, twitch_username: str):
    users = load_registered_users()
    for i, u in enumerate(users):
        if u.lower() == twitch_username.lower():
            users.pop(i)
            save_registered_users(users)
            await interaction.response.send_message(
                f"‚ùå Unregistered Twitch username **{twitch_username}**.",
                ephemeral=True
            )
            return
    await interaction.response.send_message(
        f"‚ö†Ô∏è Twitch username **{twitch_username}** not found in the list.",
        ephemeral=True
    )

@client.tree.command(name="streamer_list", description="List all registered Twitch streamers")
async def list_twitch(interaction: discord.Interaction):
    users = load_registered_users()
    if not users:
        await interaction.response.send_message("No Twitch usernames registered yet.", ephemeral=True)
    else:
        user_list = "\n".join(users)
        await interaction.response.send_message(f"**Registered Twitch usernames:**\n{user_list}", ephemeral=True)

@client.tree.command(name="add_game", description="Add a new game to the allowed games list")
@app_commands.describe(game_name="The exact name of the game to add")
async def add_game(interaction: discord.Interaction, game_name: str):
    global ALLOWED_GAMES
    game_name_lower = game_name.lower().strip()
    if game_name_lower in ALLOWED_GAMES:
        await interaction.response.send_message(f"‚ö†Ô∏è Game '{game_name}' is already in the allowed games list.", ephemeral=True)
        return
    ALLOWED_GAMES.append(game_name_lower)
    save_json_list(ALLOWED_GAMES_FILE, ALLOWED_GAMES)
    await interaction.response.send_message(f"‚úÖ Added game '{game_name}' to the allowed games list.", ephemeral=True)

@client.tree.command(name="add_keyword", description="Add a new keyword to the stream title keyword filter")
@app_commands.describe(keyword="Keyword or phrase to add to the filter")
async def add_keyword(interaction: discord.Interaction, keyword: str):
    global KEYWORD_FILTERS
    keyword_lower = keyword.lower().strip()
    if keyword_lower in KEYWORD_FILTERS:
        await interaction.response.send_message(f"‚ö†Ô∏è Keyword '{keyword}' is already in the keyword filter list.", ephemeral=True)
        return
    KEYWORD_FILTERS.append(keyword_lower)
    save_json_list(KEYWORD_FILTERS_FILE, KEYWORD_FILTERS)
    await interaction.response.send_message(f"‚úÖ Added keyword '{keyword}' to the keyword filter list.", ephemeral=True)

@client.tree.command(name="ping", description="Check bot latency")
async def ping(interaction: discord.Interaction):
    latency = client.latency * 1000
    await interaction.response.send_message(f"üèì Pong! Latency: {latency:.2f}ms", ephemeral=True)

@client.tree.command(name="restart", description="Restart the bot")
async def restart(interaction: discord.Interaction):
    await interaction.response.send_message("‚ôªÔ∏è Restarting bot...", ephemeral=True)
    subprocess.Popen([sys.executable] + sys.argv)
    await client.close()

@client.tree.command(name="list_keywords", description="Show all currently allowed stream title keywords")
async def list_keywords(interaction: discord.Interaction):
    if not KEYWORD_FILTERS:
        await interaction.response.send_message("‚ùå No keyword filters are currently set.", ephemeral=True)
    else:
        keyword_list = "\n".join(f"- `{kw}`" for kw in sorted(KEYWORD_FILTERS))
        await interaction.response.send_message(
            f"üîë **Allowed Keywords:**\n{keyword_list}",
            ephemeral=True
        )

@client.tree.command(name="list_games", description="Show all currently allowed games")
async def list_games(interaction: discord.Interaction):
    if not ALLOWED_GAMES:
        await interaction.response.send_message("‚ùå No allowed games are currently set.", ephemeral=True)
    else:
        game_list = "\n".join(f"- `{game}`" for game in sorted(ALLOWED_GAMES))
        await interaction.response.send_message(
            f"üéÆ **Allowed Games:**\n{game_list}",
            ephemeral=True
        )


# === On Ready ===
@client.event
async def on_ready():
    print(f'‚úÖ Logged in as {client.user}')
    try:
        synced = await client.tree.sync()
        print(f"üåê Synced {len(synced)} global slash command(s).")
    except Exception as e:
        print(f"‚ùå Error syncing global commands: {e}")

    guild = client.get_guild(GUILD_ID)
    channel = guild.get_channel(CHANNEL_ID) if guild else None

    if channel:
        for username, notif in list(active_notifications.items()):
            try:
                message_id = notif["message_id"]
                message = await channel.fetch_message(message_id)
                await message.delete()
                print(f"üóëÔ∏è Deleted leftover notification for {username} on startup.")
            except discord.NotFound:
                print(f"‚ö†Ô∏è Leftover notification for {username} already deleted.")
            except Exception as e:
                print(f"‚ùå Error deleting leftover notification for {username}: {e}")
            finally:
                active_notifications.pop(username, None)
        save_active_notifications(active_notifications)
    else:
        print("‚ùå Could not find channel to delete leftover notifications on startup.")

    if not check_twitch_status_task.is_running():
        check_twitch_status_task.start()

# === Run Bot ===
client.run(TOKEN)
