import os
import sys
import json
import re
import ctypes
import subprocess
import requests
import asyncio

from datetime import datetime
from dotenv import load_dotenv
from discord import app_commands
from discord.ext import tasks, commands
import discord

# Set custom console window title (Windows only)
ctypes.windll.kernel32.SetConsoleTitleW("FFIVALLRace Streamers")

# === Admin Check (Windows Only) ===
def is_admin():
    try:
        return ctypes.windll.shell32.IsUserAnAdmin()
    except:
        return False

if not is_admin():
    print("ðŸ”’ Not running as admin. Attempting to restart with admin rights...")
    args = ' '.join(f'"{arg}"' for arg in sys.argv)
    ret = ctypes.windll.shell32.ShellExecuteW(None, "runas", sys.executable, args, None, 1)
    if ret <= 32:
        print(f"âŒ Failed to elevate privileges. ShellExecuteW returned {ret}")
        sys.exit(1)
    sys.exit(0)

# === Load Environment Variables ===
load_dotenv(r"path_to_file")
TOKEN                    = os.getenv("DISCORD_TOKEN")
GUILD_ID                 = int(os.getenv("GUILD_ID",    0))
CHANNEL_ID               = int(os.getenv("CHANNEL_ID",  0))
TWITCH_CLIENT_ID         = os.getenv("TWITCH_CLIENT_ID")
TWITCH_CLIENT_SECRET     = os.getenv("TWITCH_CLIENT_SECRET")
REGISTER_FILE            = os.getenv("REGISTER_FILE",            "registered_twitch.json")
ALLOWED_GAMES_FILE       = os.getenv("ALLOWED_GAMES_FILE",       "allowed_games.json")
KEYWORD_FILTERS_FILE     = os.getenv("KEYWORD_FILTERS_FILE",     "allowed_keywords.json")
ACTIVE_NOTIFICATIONS_FILE= os.getenv("ACTIVE_NOTIFICATIONS_FILE","active_notifications.json")

# === Base Filters (fallback if JSON missing or invalid) ===
BASE_ALLOWED_GAMES   = ["final fantasy", "final fantasy iv", "final fantasy vi", "final fantasy mystic quest"]
BASE_KEYWORD_FILTERS = ["worlds collide", "free enterprise", "ff4fe", "randomizer", "ffmqr", "ff6wc"]

def load_json_list(filepath, default_list):
    if not os.path.exists(filepath):
        with open(filepath, "w") as f:
            json.dump(default_list, f, indent=4)
        return default_list.copy()
    try:
        with open(filepath, "r") as f:
            return [item.lower() for item in json.load(f)]
    except (json.JSONDecodeError, IOError):
        return default_list.copy()

def save_json_list(filepath, data):
    with open(filepath, "w") as f:
        json.dump(sorted(data), f, indent=4)

ALLOWED_GAMES   = load_json_list(ALLOWED_GAMES_FILE,   BASE_ALLOWED_GAMES)
KEYWORD_FILTERS = load_json_list(KEYWORD_FILTERS_FILE, BASE_KEYWORD_FILTERS)

print(f"Loaded allowed games:   {ALLOWED_GAMES}")
print(f"Loaded keyword filters: {KEYWORD_FILTERS}")

# === Registered Twitch Users ===
if not os.path.exists(REGISTER_FILE):
    with open(REGISTER_FILE, "w") as f:
        json.dump([], f)
    print(f"âœ… Created {REGISTER_FILE}")

def load_registered_users():
    try:
        with open(REGISTER_FILE, "r") as f:
            return json.load(f)
    except:
        save_registered_users([])
        return []

def save_registered_users(data):
    with open(REGISTER_FILE, "w") as f:
        json.dump(data, f, indent=4)

# === Active Notifications Persistence ===
def load_active_notifications():
    if not os.path.exists(ACTIVE_NOTIFICATIONS_FILE):
        return {}
    try:
        with open(ACTIVE_NOTIFICATIONS_FILE, "r") as f:
            return json.load(f)
    except:
        return {}

def save_active_notifications(data):
    with open(ACTIVE_NOTIFICATIONS_FILE, "w") as f:
        json.dump(data, f, indent=4)

active_notifications = load_active_notifications()

# === Discord Client Setup ===
intents = discord.Intents.default()
intents.message_content = True
intents.guilds = True
client = commands.Bot(command_prefix="!", intents=intents)

# === Twitch API Helpers ===
twitch_access_token = None
def get_twitch_token():
    url = "https://id.twitch.tv/oauth2/token"
    params = {
        "client_id":     TWITCH_CLIENT_ID,
        "client_secret": TWITCH_CLIENT_SECRET,
        "grant_type":    "client_credentials"
    }
    print("ðŸ”‘ Requesting new Twitch OAuth token...")
    resp = requests.post(url, params=params)
    if resp.status_code == 200:
        print("âœ… Obtained new Twitch access token.")
        return resp.json()["access_token"]
    print(f"âŒ Twitch token error: {resp.text}")
    return None

def check_twitch_status(username):
    global twitch_access_token
    if not twitch_access_token:
        twitch_access_token = get_twitch_token()
        if not twitch_access_token:
            return False, None, None

    headers = {
        "Client-ID":     TWITCH_CLIENT_ID,
        "Authorization": f"Bearer {twitch_access_token}"
    }
    url = f"https://api.twitch.tv/helix/streams?user_login={username.lower()}"
    resp = requests.get(url, headers=headers)

    if resp.status_code == 401:
        twitch_access_token = get_twitch_token()
        if not twitch_access_token:
            return False, None, None
        headers["Authorization"] = f"Bearer {twitch_access_token}"
        resp = requests.get(url, headers=headers)

    if resp.status_code != 200:
        print(f"âŒ Twitch API Error ({username}): {resp.status_code}")
        return False, None, None

    data = resp.json().get("data")
    if not data:
        print(f"â„¹ï¸ No live data for {username}.")
        return False, None, None

    stream = data[0]
    game  = stream.get("game_name","").lower()
    title = stream.get("title","")
    print(f"ðŸŽ¥ {username}: game='{game}', title='{title}'")

    keyword_hits = [kw for kw in KEYWORD_FILTERS if kw in title.lower()]
    allowed_game = game in ALLOWED_GAMES

    if allowed_game and keyword_hits:
        return True, game, title

    print(f"âš ï¸ Filtered out: game allowed? {allowed_game}, keywords? {bool(keyword_hits)}")
    return False, None, None

# === Background Loop ===
@tasks.loop(seconds=30)
async def check_twitch_status_task():
    print("ðŸ”„ Running Twitch status check...")
    guild  = client.get_guild(GUILD_ID)
    channel= guild.get_channel(CHANNEL_ID) if guild else None
    if not channel:
        print("âŒ Guild or channel not found.")
        return

    users = load_registered_users()
    print(f"âœ… Checking {len(users)} registered users.")

    for user in users:
        live, game, title = check_twitch_status(user)
        print(f"â„¹ï¸ {user} live? {live}")
        # New live
        if live and user not in active_notifications:
            msg = await channel.send(f"ðŸ”´ **{user} is live!**\nðŸŽ® {game}\nðŸ“º {title}\nhttps://twitch.tv/{user}")
            active_notifications[user] = {"message_id": msg.id, "last_title": title}
            save_active_notifications(active_notifications)

        # Title change
        elif live and user in active_notifications:
            prev = active_notifications[user]["last_title"]
            if title != prev:
                try:
                    msg = await channel.fetch_message(active_notifications[user]["message_id"])
                    stamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                    await msg.edit(content=(
                        f"ðŸ”´ **{user} is live!**\nðŸŽ® {game}\nðŸ“º {title}\n"
                        f"https://twitch.tv/{user}\n*Updated: {stamp}*"
                    ))
                    active_notifications[user]["last_title"] = title
                    save_active_notifications(active_notifications)
                    print(f"âœ… Updated {user}'s notification.")
                except discord.NotFound:
                    print(f"âš ï¸ Old message for {user} not found; sending new one.")
                    # fallback to send new message
                    msg = await channel.send(f"ðŸ”´ **{user} is live!**\nðŸŽ® {game}\nðŸ“º {title}\nhttps://twitch.tv/{user}")
                    active_notifications[user] = {"message_id": msg.id, "last_title": title}
                    save_active_notifications(active_notifications)

        # Went offline
        elif not live and user in active_notifications:
            try:
                msg = await channel.fetch_message(active_notifications[user]["message_id"])
                await msg.delete()
                print(f"âŒ {user} went offline; notification removed.")
            except discord.NotFound:
                print(f"âš ï¸ Notification for {user} already gone.")
            active_notifications.pop(user, None)
            save_active_notifications(active_notifications)

# === Slash Commands ===
@client.tree.command(name="register", description="Add a Twitch streamer")
async def register_twitch(interaction: discord.Interaction, twitch_username: str):
    uname = twitch_username.strip()
    if not re.match(r"^[A-Za-z0-9_]+$", uname):
        return await interaction.response.send_message(
            "âŒ Invalid username.", ephemeral=True
        )
    users = load_registered_users()
    if any(u.lower()==uname.lower() for u in users):
        return await interaction.response.send_message(
            f"âš ï¸ {uname} already registered.", ephemeral=True
        )
    users.append(uname)
    save_registered_users(users)
    await interaction.response.send_message(f"âœ… Registered {uname}.", ephemeral=True)

@client.tree.command(name="unregister", description="Remove a Twitch streamer")
async def unregister_twitch(interaction: discord.Interaction, twitch_username: str):
    users = load_registered_users()
    for i,u in enumerate(users):
        if u.lower()==twitch_username.lower():
            users.pop(i)
            save_registered_users(users)
            return await interaction.response.send_message(
                f"âŒ Unregistered {twitch_username}.", ephemeral=True
            )
    await interaction.response.send_message(
        f"âš ï¸ {twitch_username} not found.", ephemeral=True
    )

@client.tree.command(name="streamer_list", description="List registered streamers")
async def list_twitch(interaction: discord.Interaction):
    users = load_registered_users()
    if not users:
        return await interaction.response.send_message("No streamers registered.", ephemeral=True)
    await interaction.response.send_message(
        "**Registered:**\n" + "\n".join(users),
        ephemeral=True
    )

@client.tree.command(name="list_games", description="Show allowed games")
async def list_games(interaction: discord.Interaction):
    await interaction.response.send_message(
        "ðŸŽ® **Allowed Games:**\n" + "\n".join(f"- {g}" for g in ALLOWED_GAMES),
        ephemeral=True
    )

@client.tree.command(name="list_keywords", description="Show keyword filters")
async def list_keywords(interaction: discord.Interaction):
    await interaction.response.send_message(
        "ðŸ”‘ **Allowed Keywords:**\n" + "\n".join(f"- {k}" for k in KEYWORD_FILTERS),
        ephemeral=True
    )

@client.tree.command(name="ping", description="Check latency")
async def ping(interaction: discord.Interaction):
    await interaction.response.send_message(f"ðŸ“ Pong! {client.latency*1000:.2f}ms", ephemeral=True)

@client.tree.command(name="restart", description="Restart the bot")
async def restart(interaction: discord.Interaction):
    await interaction.response.send_message("â™»ï¸ Restarting...", ephemeral=True)
    subprocess.Popen([sys.executable] + sys.argv)
    await client.close()

# === Startup ===
@client.event
async def on_ready():
    print(f"âœ… Logged in as {client.user}")
    try:
        synced = await client.tree.sync()
        print(f"ðŸŒ Synced {len(synced)} slash commands.")
    except Exception as e:
        print(f"âŒ Sync error: {e}")

    # Clean up leftover notifications
    guild = client.get_guild(GUILD_ID)
    channel = guild.get_channel(CHANNEL_ID) if guild else None
    if channel:
        for user, info in list(active_notifications.items()):
            try:
                msg = await channel.fetch_message(info["message_id"])
                await msg.delete()
                print(f"ðŸ—‘ï¸ Removed old notif for {user}")
            except discord.NotFound:
                print(f"âš ï¸ Notification for {user} already gone.")
            except Exception as e:
                print(f"âŒ Error removing old notif for {user}: {e}")
            active_notifications.pop(user, None)
        save_active_notifications(active_notifications)
    else:
        print("âŒ Couldn't find channel for cleanup.")

    # Start Twitch check loop if not already running
    if not check_twitch_status_task.is_running():
        check_twitch_status_task.start()

# === Run ===
client.run(TOKEN)
